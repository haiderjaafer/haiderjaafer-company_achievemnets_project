async def get_async_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session

In Python, yield session and the function signature 
async def get_async_db() -> AsyncGenerator[AsyncSession, None]: are intrinsically linked.
The yield statement is what actually creates the AsyncGenerator described in your return type. 
Here is the connection between the two:Yield defines the Return Type: In Python, adding a yield statement to a function automatically transforms it from a regular function into a generator function.
Therefore, the return type must be declared as an AsyncGenerator (or similar iterator type) because the function no longer returns a single value; 
it returns a generator object that produces values over time.The Type Parameters: The type hint AsyncGenerator[AsyncSession,
None] specifically matches what you wrote in the function body:AsyncSession: This is the type of the value you are yielding (the session object).None: This indicates that the generator does not expect any value to be sent back into it during the request.Lifecycle Management: Unlike a standard return, 
which would immediately exit the function and close the async with block (thus closing your database connection before you could use it), 
yield allows the function to pause and provide the session to your API route. 


-------------------------------------------------

Request comes in
↓
FastAPI calls get_async_db() → async generator object
↓
Enter async with → create AsyncSession
↓
yield session → give session to endpoint
↓
endpoint runs queries with db
↓
endpoint finishes → generator resumes
↓
async with exits → session closed
↓
Request complete
----------------------------------------------------

Mental Model
Think of it like this:

Generator function = factory for sessions.

Yield = “Here’s the session, use it for this request.”

After yield = “Okay, request is done, now I’ll clean up

------------------------------------------------------------

async with 
is a Python syntax used with context managers in asynchronous code, 
allowing you to await the setup and teardown of resources (like network connections or files) while the main program continues running other tasks,
preventing the thread from blocking and improving efficiency for I/O-bound operations

-----------------------------------------------------------------

A context manager 
in Python is an object that guarantees the proper setup and teardown of resources,
 even if errors occur during a program's execution

 such as 
Opening and closing files (open() function)
Connecting and disconnecting from databases or networks

-------------------------------------------------------------

engine = create_async_engine(
    settings.sqlalchemy_database_url,  # must be mssql+aioodbc://
    echo=False,
    future=True,
    pool_size=5,
    max_overflow=2,
    pool_timeout=30
)

1- settings.sqlalchemy_database_url
This is the connection string.

2- echo=False
Controls SQL logging.

If True, SQLAlchemy will print every SQL statement it executes to the console (great for debugging).

If False, it stays quiet (better for production).

3-future=True

Enables SQLAlchemy 2.0-style behaviors even if you’re on 1.4.

This makes your code forward-compatible:

Unified Session API.

Modern transaction handling.

Cleaner async support.

4. pool_size=5
Sets the number of persistent connections in the connection pool.

Think of it as: “keep up to 5 open connections ready to hand out.”

If 10 requests come in at once, the first 5 get pooled connections, the rest wait or trigger overflow.

5. max_overflow=2
Allows extra temporary connections beyond pool_size.

Here: up to 2 more connections can be opened if all 5 in the pool are busy.

So max concurrent connections = pool_size + max_overflow = 7


6. pool_timeout=30
Maximum wait time (seconds) for a connection from the pool.

If all 7 connections are busy and another request comes in:

SQLAlchemy waits up to 30 seconds for a connection to free up.

If none free up → raises TimeoutError.



Request 1 → gets pooled connection #1
Request 2 → gets pooled connection #2
...
Request 5 → gets pooled connection #5
Request 6 → triggers overflow → new temp connection #6
Request 7 → triggers overflow → new temp connection #7
Request 8 → waits up to 30s (pool_timeout)
    if no connection frees → TimeoutError

    


 